(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{445:function(a,t,r){"use strict";r.r(t);var e=r(46),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),r("h2",{attrs:{id:"_1-数组-array"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组-array"}},[a._v("#")]),a._v(" 1.数组(Array)")]),a._v(" "),r("p",[a._v("数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始")]),a._v(" "),r("h2",{attrs:{id:"_2-栈-stack"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-栈-stack"}},[a._v("#")]),a._v(" 2.栈(Stack)")]),a._v(" "),r("p",[a._v("栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。")]),a._v(" "),r("ul",[r("li",[a._v("栈： 先进后出（入口出口在同一侧）")])]),a._v(" "),r("h2",{attrs:{id:"_3-队列-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-队列-queue"}},[a._v("#")]),a._v(" 3.队列(Queue)")]),a._v(" "),r("p",[a._v("队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队。")]),a._v(" "),r("ul",[r("li",[a._v("队列：先进先出（入口出口在两侧，分开的）")])]),a._v(" "),r("h2",{attrs:{id:"_4-链表-linked-list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-链表-linked-list"}},[a._v("#")]),a._v(" 4.链表（Linked List）")]),a._v(" "),r("p",[a._v("链表像是数组。链表和数组都是用于存储有序元素的集合，但有几点大不相同")]),a._v(" "),r("ul",[r("li",[a._v("链表不同于数组，链表中的元素在内存中并不是连续放置的")]),a._v(" "),r("li",[a._v("链表添加或移除元素不需要移动其他元素")]),a._v(" "),r("li",[a._v("数组可以直接访问任何一个位置的元素，链表必须从表头开始迭代到指定位置访问")])]),a._v(" "),r("h2",{attrs:{id:"_5-树-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-树-tree"}},[a._v("#")]),a._v(" 5.树(Tree)")]),a._v(" "),r("p",[a._v("树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合")]),a._v(" "),r("h2",{attrs:{id:"_6-堆-heap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-堆-heap"}},[a._v("#")]),a._v(" 6.堆（Heap）")]),a._v(" "),r("p",[a._v("堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。")]),a._v(" "),r("h2",{attrs:{id:"_7-图-graph"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-图-graph"}},[a._v("#")]),a._v(" 7. 图（Graph）")]),a._v(" "),r("p",[a._v("图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。")]),a._v(" "),r("ul",[r("li",[a._v("按照顶点指向的方向可分为无向图和有向图")])]),a._v(" "),r("h2",{attrs:{id:"_8-散列表-hash"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-散列表-hash"}},[a._v("#")]),a._v(" 8.散列表(Hash)")]),a._v(" "),r("p",[a._v("散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。")]),a._v(" "),r("h4",{attrs:{id:"参考-js数据结构与算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考-js数据结构与算法"}},[a._v("#")]),a._v(" "),r("a",{attrs:{href:"https://segmentfault.com/a/1190000017905515",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考-JS数据结构与算法"),r("OutboundLink")],1)]),a._v(" "),r("h4",{attrs:{id:"参考-数据结构-八大数据结构分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考-数据结构-八大数据结构分类"}},[a._v("#")]),a._v(" "),r("a",{attrs:{href:"https://blog.csdn.net/yeyazhishang/article/details/82353846",target:"_blank",rel:"noopener noreferrer"}},[a._v("参考-数据结构：八大数据结构分类"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);